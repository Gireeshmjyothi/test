package com.rajput.service;

import com.rajput.dto.MerchantOrderPayment;
import com.rajput.dto.ResponseDto;
import com.rajput.dto.UnMatchedDto;
import com.rajput.util.jdbcQuery.JdbcQuery;
import com.rajput.validator.FileValidator;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class ComparisonService {

    private final JdbcReaderService jdbcReaderService;
    private final FileProcessorService fileProcessorService;

    public ResponseDto process() {
        long startTime = System.currentTimeMillis();

        ResponseDto responseDto = new ResponseDto();
        List<UnMatchedDto> unMatchedRecords = new ArrayList<>();

        // Load DB data
        String query = JdbcQuery.getYesterdayQuery("MERCHANT_ORDER_PAYMENTS", System.currentTimeMillis());
        List<MerchantOrderPayment> dbRecords = jdbcReaderService.readJdbcQuery(query);
        Map<String, MerchantOrderPayment> dbMap = dbRecords.stream()
                .filter(r -> r.getAtrnNum() != null)
                .collect(Collectors.toMap(MerchantOrderPayment::getAtrnNum, Function.identity(), (a, b) -> a));

        // Load file data
        List<MerchantOrderPayment> fileRecords = fileProcessorService.readCsv("data/merchantOrderPayment.csv");
        Map<String, MerchantOrderPayment> fileMap = fileRecords.stream()
                .filter(r -> r.getAtrnNum() != null)
                .collect(Collectors.toMap(MerchantOrderPayment::getAtrnNum, Function.identity(), (a, b) -> a));

        responseDto.setFileRecordCount((long) fileRecords.size());

        // Find matched records (in both DB and file)
        List<MerchantOrderPayment> matched = fileRecords.stream()
                .filter(r -> dbMap.containsKey(r.getAtrnNum()))
                .collect(Collectors.toList());
        responseDto.setMatchedRecords(matched);

        // Find unmatched records (in file but not in DB)
        List<MerchantOrderPayment> unmatched = fileRecords.stream()
                .filter(r -> !dbMap.containsKey(r.getAtrnNum()))
                .collect(Collectors.toList());

        for (MerchantOrderPayment fileRecord : unmatched) {
            UnMatchedDto unMatchedDto = new UnMatchedDto();
            unMatchedDto.setDbMerchantOrderPayment(fileRecord);
            unMatchedRecords.add(unMatchedDto);
        }

        responseDto.setUnMatchedRecords(unMatchedRecords);

        long endTime = System.currentTimeMillis();
        responseDto.setTimeToProcessed(formatMillis(endTime - startTime));

        return responseDto;
    }

    public static String formatMillis(long millis) {
        long hours = millis / (1000 * 60 * 60);
        long minutes = (millis / (1000 * 60)) % 60;
        long seconds = (millis / 1000) % 60;
        long ms = millis % 1000;

        return String.format("%02d:%02d:%02d.%03d", hours, minutes, seconds, ms);
    }
}


package com.rajput.service;

import com.rajput.dto.MerchantOrderPayment;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.List;

@Service
@Slf4j
public class FileProcessorService {

    public List<MerchantOrderPaymentDto> readCSVByJava(String filePath) {
        List<MerchantOrderPaymentDto> records = new ArrayList<>();
        String line;
        try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {
            String header = br.readLine(); // skip header
            while ((line = br.readLine()) != null) {
                String[] fields = line.split(",");

                MerchantOrderPaymentDto mop = new MerchantOrderPaymentDto();
                mop.setMId(fields[0]);
                mop.setOrderRefNumber(fields[1]);
                mop.setSbiOrderRefNumber(fields[2]);
                mop.setAtrnNumber(fields[3]);
                mop.setDebitAmount(BigDecimal.valueOf(Double.parseDouble(fields[13])));

                records.add(mop);
            }
        } catch (Exception e) {
            log.error("Error reading file: {}", e.getMessage());
        }
        return records;
    }
}
