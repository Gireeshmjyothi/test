package com.rajput.service;

import com.rajput.dto.MerchantOrderPayment;
import com.rajput.dto.ResponseDto;
import com.rajput.dto.UnMatchedDto;
import com.rajput.util.jdbcQuery.JdbcQuery;
import com.rajput.validator.FileValidator;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class ComparisonService {

    private final JdbcReaderService jdbcReaderService;
    private final FileProcessorService fileProcessorService;

    public ResponseDto process() {
        long startTime = System.currentTimeMillis();

        ResponseDto responseDto = new ResponseDto();
        List<UnMatchedDto> unMatchedRecords = new ArrayList<>();

        // Load DB data
        String query = JdbcQuery.getYesterdayQuery("MERCHANT_ORDER_PAYMENTS", System.currentTimeMillis());
        List<MerchantOrderPayment> dbRecords = jdbcReaderService.readJdbcQuery(query);
        Map<String, MerchantOrderPayment> dbMap = dbRecords.stream()
                .filter(r -> r.getAtrnNum() != null)
                .collect(Collectors.toMap(MerchantOrderPayment::getAtrnNum, Function.identity(), (a, b) -> a));

        // Load file data
        List<MerchantOrderPayment> fileRecords = fileProcessorService.readCsv("data/merchantOrderPayment.csv");
        Map<String, MerchantOrderPayment> fileMap = fileRecords.stream()
                .filter(r -> r.getAtrnNum() != null)
                .collect(Collectors.toMap(MerchantOrderPayment::getAtrnNum, Function.identity(), (a, b) -> a));

        responseDto.setFileRecordCount((long) fileRecords.size());

        // Find matched records (in both DB and file)
        List<MerchantOrderPayment> matched = fileRecords.stream()
                .filter(r -> dbMap.containsKey(r.getAtrnNum()))
                .collect(Collectors.toList());
        responseDto.setMatchedRecords(matched);

        // Find unmatched records (in file but not in DB)
        List<MerchantOrderPayment> unmatched = fileRecords.stream()
                .filter(r -> !dbMap.containsKey(r.getAtrnNum()))
                .collect(Collectors.toList());

        for (MerchantOrderPayment fileRecord : unmatched) {
            UnMatchedDto unMatchedDto = new UnMatchedDto();
            unMatchedDto.setDbMerchantOrderPayment(fileRecord);
            unMatchedRecords.add(unMatchedDto);
        }

        responseDto.setUnMatchedRecords(unMatchedRecords);

        long endTime = System.currentTimeMillis();
        responseDto.setTimeToProcessed(formatMillis(endTime - startTime));

        return responseDto;
    }

    public static String formatMillis(long millis) {
        long hours = millis / (1000 * 60 * 60);
        long minutes = (millis / (1000 * 60)) % 60;
        long seconds = (millis / 1000) % 60;
        long ms = millis % 1000;

        return String.format("%02d:%02d:%02d.%03d", hours, minutes, seconds, ms);
    }
}


package com.rajput.service;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;

public List<MerchantOrderPaymentDto> readCSVByJava(String filePath) {
    List<MerchantOrderPaymentDto> records = new ArrayList<>();

    try (Reader reader = new FileReader(filePath);
         CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT.withFirstRecordAsHeader())) {

        for (CSVRecord csvRecord : csvParser) {
            MerchantOrderPaymentDto mop = new MerchantOrderPaymentDto();
            mop.setMId(csvRecord.get(0));
            mop.setOrderRefNumber(csvRecord.get(1));
            mop.setSbiOrderRefNumber(csvRecord.get(2));
            mop.setAtrnNumber(csvRecord.get(3));

            String amount = csvRecord.get(13);
            mop.setDebitAmount(new BigDecimal(amount.isEmpty() ? "0" : amount));

            records.add(mop);
        }

    } catch (Exception e) {
        log.error("Error reading CSV file", e);  // full stack trace
    }

    return records;
}
